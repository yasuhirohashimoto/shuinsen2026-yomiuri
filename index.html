<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>衆院選2026 候補者：政策志向マップ</title>

    <!-- =========================
       Styles
       ========================= -->
    <style>
        /* -------------------------
       1) Design tokens
       ------------------------- */
        :root {
            --bg-glass: rgba(255, 255, 255, 0.9);
            --bg-glass-dark: rgba(0, 0, 0, 0.8);
            --primary-color: #1f77b4;
            --border-color: rgba(0, 0, 0, 0.1);
            --text-main: #333;
            --text-sub: #666;
            --accent-blue: #4fc3f7;

            --radius-lg: 16px;
            --radius-md: 8px;
            --radius-sm: 4px;

            --shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);

            --z-ui: 1000;
            --z-modal: 2000;
            --z-tooltip: 3000;
        }

        /* -------------------------
       2) Base
       ------------------------- */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: "Noto Sans JP", "Meiryo", sans-serif;
            background-color: #f8f9fa;
            color: var(--text-main);
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* -------------------------
       3) Shared UI blocks
       ------------------------- */
        #legend,
        #filter-panel {
            position: absolute;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            z-index: var(--z-ui);
        }

        /* -------------------------
       4) Search UI
       ------------------------- */
        #search-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: var(--z-ui);
            width: 320px;
        }

        #search-input {
            width: 100%;
            padding: 12px 20px;
            border-radius: 30px;
            border: 1px solid var(--border-color);
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            font-size: 16px;
            box-shadow: var(--shadow);
            outline: none;
            transition: var(--transition);
            -webkit-appearance: none;
        }

        #search-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(31, 119, 180, 0.2);
        }

        #search-results {
            list-style: none;
            margin: 8px 0 0 0;
            padding: 8px;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow);
            max-height: 300px;
            overflow-y: auto;
            display: none;
            border: 1px solid var(--border-color);
        }

        .search-item {
            padding: 10px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }

        .search-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .search-party {
            font-size: 11px;
            color: var(--text-sub);
            background: rgba(0, 0, 0, 0.08);
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* -------------------------
       5) Legend UI
       ------------------------- */
        #legend {
            bottom: 30px;
            right: 30px;
            padding: 20px;
            min-width: 220px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 14px;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 12px;
            font-size: 16px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            cursor: pointer;
            padding: 6px 10px;
            transition: var(--transition);
            border-left: 4px solid transparent;
            border-radius: var(--radius-sm);
            -webkit-tap-highlight-color: transparent;
        }

        .legend-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .legend-item.selected {
            background-color: rgba(0, 0, 0, 0.08);
            border-left: 4px solid var(--primary-color);
            font-weight: bold;
        }

        .legend-icon {
            width: 18px;
            height: 18px;
            margin-right: 12px;
            border-radius: 2px;
        }

        /* -------------------------
       6) About button & modal
       ------------------------- */
        #about-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
            z-index: var(--z-ui);
            font-size: 20px;
            color: var(--text-sub);
            box-shadow: var(--shadow);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: var(--transition);
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        @media (hover: hover) {
            #about-btn:hover {
                background: var(--primary-color);
                color: white;
                transform: scale(1.05);
            }
        }

        #about-btn:active {
            transform: scale(0.95);
        }

        #about-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: var(--z-modal);
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #about-content {
            color: var(--text-main);
            background: white;
            padding: 40px;
            border-radius: var(--radius-lg);
            max-width: 640px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            line-height: 1.8;
        }

        #about-content h2 {
            margin: 0 0 24px 0;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
            font-size: 24px;
            text-align: center;
        }

        #about-content h3 {
            font-size: 18px;
            margin-top: 32px;
            margin-bottom: 12px;
        }

        #close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #bbb;
            transition: var(--transition);
            -webkit-tap-highlight-color: transparent;
        }

        #close-modal:hover {
            color: var(--text-main);
            transform: rotate(90deg);
        }

        /* -------------------------
       7) Tooltip
       ------------------------- */
        #tooltip {
            position: absolute;
            display: none;
            background: var(--bg-glass-dark);
            backdrop-filter: blur(8px);
            color: #fff;
            padding: 14px;
            border-radius: var(--radius-md);
            font-size: 13px;
            z-index: var(--z-tooltip);
            line-height: 1.6;
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
            /* PCではスルー。モバイルはmediaで有効化 */
            min-width: 200px;
        }

        #tooltip strong {
            font-size: 16px;
            display: block;
            margin-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 4px;
        }

        .tooltip-party {
            font-size: 12px;
            margin-bottom: 5px;
            color: #ddd;
        }

        /* 既存仕様に合わせ「回答一覧全体」を強調表示するスタイルを維持 */
        .tooltip-answers {
            font-family: "Roboto Mono", monospace;
            color: var(--accent-blue);
            font-weight: bold;
            font-size: 12px;
            line-height: 1.6;
            word-break: break-word;
        }

        /* -------------------------
       8) Policy filter panel
       ------------------------- */
        #filter-panel {
            bottom: 30px;
            left: 30px;
            width: 300px;
            padding: 16px;
            transition: var(--transition);
        }

        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .filter-reset-btn {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            padding: 6px 10px;
            cursor: pointer;
            color: var(--text-sub);
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
        }

        .filter-reset-btn:hover {
            background: #eee;
            color: #333;
        }

        .filter-reset-btn:active {
            transform: scale(0.98);
        }

        #issue-select {
            width: 100%;
            padding: 8px;
            border-radius: var(--radius-sm);
            border: 1px solid #ccc;
            background: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-bottom: 16px;
            outline: none;
        }

        .filter-control.is-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-sub);
            margin-bottom: 4px;
        }

        .range-labels span {
            max-width: 45%;
        }

        #value-range {
            width: 100%;
            margin: 8px 0;
            cursor: pointer;
        }

        .range-value-display {
            text-align: center;
            font-weight: bold;
            color: var(--primary-color);
            font-size: 14px;
        }

        /* -------------------------
       9) Mobile
       ------------------------- */
        @media (max-width: 600px) {

            /* layout tweaks */
            #search-container {
                width: calc(100% - 80px);
                top: 15px;
                left: 15px;
            }

            #about-btn {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
            }

            #about-content {
                padding: 30px 20px;
                width: 95%;
                font-size: 14px;
            }

            #legend {
                left: 15px;
                right: 15px;
                bottom: 15px;
                max-height: 200px;
                padding: 12px;
            }

            /* fallback: JSが動く前の初期位置（JSで上書き） */
            #filter-panel {
                left: 15px;
                width: calc(100% - 30px);
                bottom: 220px;
            }

            /* tooltip is tappable on mobile */
            #tooltip {
                pointer-events: auto;
                cursor: pointer;
            }

            /* ---------- mobile: tap header to minimize/expand ---------- */
            #legend .legend-title,
            #filter-panel .filter-header {
                cursor: pointer;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }

            /* caret on legend title */
            #legend .legend-title {
                position: relative;
                padding-right: 22px;
            }

            #legend .legend-title::after {
                content: "▾";
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                color: var(--text-sub);
                font-weight: bold;
            }

            #legend.minimized .legend-title::after {
                content: "▸";
            }

            /* caret on filter title */
            #filter-panel .filter-title {
                position: relative;
                padding-right: 22px;
            }

            #filter-panel .filter-title::after {
                content: "▾";
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                color: var(--text-sub);
                font-weight: bold;
            }

            #filter-panel.minimized .filter-title::after {
                content: "▸";
            }

            /* minimized: legend */
            #legend.minimized {
                max-height: 52px;
                overflow: hidden;
                padding: 12px;
            }

            #legend.minimized .legend-item {
                display: none;
            }

            #legend.minimized .legend-title {
                margin-bottom: 0;
                padding-bottom: 0;
                border-bottom: none;
            }

            /* minimized: filter */
            #filter-panel.minimized {
                padding: 12px;
            }

            #filter-panel.minimized .filter-row,
            #filter-panel.minimized .filter-control {
                display: none;
            }

            #filter-panel.minimized .filter-header {
                margin-bottom: 0;
                padding-bottom: 0;
                border-bottom: none;
            }
        }
    </style>

    <!-- =========================
       Libraries
       ========================= -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <!-- Search -->
    <div id="search-container">
        <input type="text" id="search-input" placeholder="候補者名・政党名で検索" />
        <ul id="search-results"></ul>
    </div>

    <!-- Tooltip -->
    <div id="tooltip"></div>

    <!-- About -->
    <button id="about-btn" title="このサイトについて" aria-label="このサイトについて">?</button>

    <div id="about-modal">
        <div id="about-content">
            <span id="close-modal" aria-label="閉じる">&times;</span>

            <h2>このマップについて</h2>
            <p>
                この3Dマップは、衆議院選挙（2026年）における各候補者の政策志向についてのアンケートデータを分析し、回答傾向が似ている候補者同士が近くになるように配置したものです。
            </p>

            <h3>データ出典</h3>
            <p>
                <a href="https://www.yomiuri.co.jp/election/shugiin/2026candidates/" target="_blank"
                    rel="noopener noreferrer">
                    読売新聞オンライン「衆院選2026　立候補者一覧」
                </a>
            </p>

            <h3>使用データと集計方法</h3>
            <ul>
                <li><strong>対象設問（Q2～Q23）:</strong></li>
                <li>
                    <strong>データ処理:</strong><br />
                    各種政策に対する志向を問う数値データ（Q2〜Q23）のみを抽出し、各質問に対する回答を標準化しています。「回答なし」は、全回答者の平均値に置き換えています。<br />
                    ※ 完全に同一な値を持つ候補者の位置をずらして見やすくするために、元ベクトルの各成分に平均0、標準偏差0.05のガウシアンノイズを加えています。
                </li>
            </ul>

            <h3>分析手法：主成分分析 (PCA)</h3>
            <p>27次元（質問数）の回答データを、情報の損失をなるべく抑えつつ3次元空間に圧縮しました。</p>
            <ul>
                <li><strong>第1主成分 (PC1):</strong> 寄与率 <strong>35.4%</strong></li>
                <li><strong>第2主成分 (PC2):</strong> 寄与率 <strong>17.0%</strong></li>
                <li><strong>第3主成分 (PC3):</strong> 寄与率 <strong>6.6%</strong></li>
                <li><strong>累積寄与率:</strong> <strong>59.0%</strong>（データの約59%の情報がこの図で説明されています）</li>
            </ul>

            <h3>操作方法</h3>
            <ul>
                <li><strong>回転：</strong> 指一本でドラッグ (PC：左ドラッグ)</li>
                <li><strong>ズーム：</strong> 二本指でピンチ (PC：ホイール)</li>
                <li><strong>移動：</strong> 二本指でスワイプ (PC：右ドラッグ)</li>
                <li><strong>詳細：</strong> 点をタップ (PC：ホバー)</li>
            </ul>
        </div>
    </div>

    <!-- Legend -->
    <div id="legend">
        <div class="legend-title">政党一覧</div>
    </div>

    <!-- Policy filter -->
    <div id="filter-panel">
        <div class="filter-header">
            <span class="filter-title">政策で絞り込み</span>
            <button id="filter-reset" class="filter-reset-btn" type="button" aria-label="政策フィルターをリセット">
                ↺ リセット
            </button>
        </div>

        <div class="filter-row">
            <select id="issue-select">
                <option value="">質問項目を選択...</option>
            </select>
        </div>

        <!-- 初期状態は disabled（CSSクラスで管理） -->
        <div class="filter-control is-disabled" id="filter-control">
            <div class="range-labels">
                <span id="label-low">---</span>
                <span id="label-high">---</span>
            </div>
            <input type="range" id="value-range" min="1" max="5" step="1" value="3" />
            <div class="range-value-display">
                回答: <span id="current-val-text">-</span>
            </div>
        </div>
    </div>

    <!-- =========================
       Script
       ========================= -->
    <script>
        async function loadData() {
            try {
                const [candidatesRes, partiesRes] = await Promise.all([
                    fetch('./data/candidates.json'),
                    fetch('./data/parties.json')
                ]);
                if (!candidatesRes.ok || !partiesRes.ok) {
                    throw new Error("ファイルの取得に失敗しました");
                }
                const candidates = await candidatesRes.json();
                const parties = await partiesRes.json();
                return { candidates, parties };

            } catch (error) {
                console.error("データの読み込みに失敗しました:", error);
                alert("データを読み込めませんでした。");
                return null;
            }
        }

        async function main() {

            /* ==========================================================
               0) Data
               ========================================================== */
            const data = await loadData();
            if (!data) return;

            const pointsData = data.candidates;
            const legendData = data.parties;

            const qdata = {
                "Q2. 社会保障負担": ["給付維持×負担増", "給付減×負担減", 5],
                "Q3. 高齢者医療費3割": ["賛成", "反対", 5],
                "Q4. 外国人受入": ["増やす", "減らす", 5],
                "Q5. 消費税": ["増税", "減税・廃止", 4],
                "Q6. 経済政策": ["財政出動", "財政再建", 5],
                "Q7. 経済方針": ["成長重視", "分配重視", 5],
                "Q8. 原発": ["活用", "廃止", 5],
                "Q9-a. 公共事業費": ["増額", "削減", 5],
                "Q9-b. 医療・介護費": ["増額", "削減", 5],
                "Q9-c. 科学技術費": ["増額", "削減", 5],
                "Q9-d. 公務員人件費": ["増額", "削減", 5],
                "Q9-e. 生活保護費": ["増額", "削減", 5],
                "Q9-f. 子育て支援費": ["増額", "削減", 5],
                "Q10. 防衛・安全保障費": ["増額", "減額", 3],
                "Q11. 防衛装備輸出": ["賛成", "反対", 5],
                "Q12. 対米関係強化": ["賛成", "反対", 5],
                "Q13. 対中関係強化": ["賛成", "反対", 5],
                "Q14. 対韓関係強化": ["賛成", "反対", 5],
                "Q15. 皇位継承": ["男系男子維持", "女系容認・天皇制廃止", 4],
                "Q16. 憲法改正": ["賛成", "反対", 5],
                "Q17. 緊急事態条項": ["賛成", "反対", 5],
                "Q18. 夫婦別姓": ["同姓維持", "別姓導入", 3],
                "Q19. 企業団体献金": ["存続", "禁止", 5],
                "Q20. 選挙時のSNS偽情報対策": ["自由尊重", "規制強化", 5],
                "Q21. 選挙時のSNS収益化": ["自由尊重", "規制強化", 5],
                "Q22. 定数削減": ["賛成", "反対", 5],
                "Q23. 政党制": ["二大政党制", "多党制", 5]
            };

            /*==========================================================
              1) Constants / Theme
              ==========================================================*/
            const THEME = {
                colors: {
                    grid: 0xcccccc,
                    axisX: 0xff0000,
                    axisY: 0x00aa00,
                    axisZ: 0x0000ff,
                    text: "#333333"
                }, opacity: {
                    point: 0.85,
                    label: 0.9,
                    dimmed: 0.15,
                    filteredOutStrong: 0.1
                }, duration: {
                    hover: 0.3,
                    camera: 1.5,
                    filter: 0.3,
                    resetScale: 0.2
                }
            };

            const BASE_URL = "https://www.yomiuri.co.jp/election/shugiin/2026/";
            const UI_SELECTORS = "#about-modal, #legend, #search-container, #about-btn, #search-results, #tooltip, #filter-panel";
            const POLICY_KEYS = Object.keys(qdata);
            const Q_ENTRIES = Object.entries(qdata);

            /*==========================================================
              2) Texture helpers (cache heavy objects) 
              - shape texture: CanvasTexture cache 
              - legend icon: dataURL cache 
              - material template: new material creation helper
              ==========================================================*/
            const shapeTextureCache = new Map(); // key: "shape|#RRGGBB" -> THREE.CanvasTexture
            const shapeDataUrlCache = new Map(); // key: "shape|#RRGGBB" -> dataURL

            function drawShapeToCanvas(type, color) {
                const size = 64;
                const canvas = document.createElement("canvas");
                canvas.width = size;
                canvas.height = size;

                const ctx = canvas.getContext("2d");
                ctx.fillStyle = color;

                const center = size / 2;
                const radius = size / 2 - 4;
                const pad = 6;

                ctx.beginPath();
                if (type === 0) {
                    ctx.arc(center, center, radius, 0, Math.PI * 2);
                } else if (type === 1) {
                    ctx.rect(pad, pad, size - pad * 2, size - pad * 2);
                } else if (type === 2) {
                    ctx.moveTo(center, pad);
                    ctx.lineTo(size - pad, size - pad);
                    ctx.lineTo(pad, size - pad);
                    ctx.closePath();
                } else if (type === 3) {
                    ctx.moveTo(center, pad);
                    ctx.lineTo(size - pad, center);
                    ctx.lineTo(center, size - pad);
                    ctx.lineTo(pad, center);
                    ctx.closePath();
                } else if (type === 4) {
                    const w = 2 * pad;
                    ctx.moveTo(center - w, pad); ctx.lineTo(center + w, pad);
                    ctx.lineTo(center + w, center - w); ctx.lineTo(size - pad, center - w);
                    ctx.lineTo(size - pad, center + w); ctx.lineTo(center + w, center + w);
                    ctx.lineTo(center + w, size - pad); ctx.lineTo(center - w, size - pad);
                    ctx.lineTo(center - w, center + w); ctx.lineTo(pad, center + w);
                    ctx.lineTo(pad, center - w); ctx.lineTo(center - w, center - w);
                    ctx.closePath();
                } else {
                    ctx.arc(center, center, radius, 0, Math.PI * 2);
                }

                ctx.fill();
                return canvas;
            }

            function getShapeTexture(type, color) {
                const key = `${type}|${color}`;
                if (!shapeTextureCache.has(key)) {
                    const canvas = drawShapeToCanvas(type, color);
                    shapeTextureCache.set(key, new THREE.CanvasTexture(canvas));
                }
                return shapeTextureCache.get(key);
            }

            function getShapeDataUrl(type, color) {
                const key = `${type}|${color}`;
                if (!shapeDataUrlCache.has(key)) {
                    const tex = getShapeTexture(type, color);
                    shapeDataUrlCache.set(key, tex.image.toDataURL());
                }
                return shapeDataUrlCache.get(key);
            }

            /**
            * 候補者ごとに opacity を変えるため、material は「共有しない」方針。
            * - map(Texture)はキャッシュから共有してOK
            * - material自体は個別生成（cloneでもOKだが、ここでは明示的に生成）
            */
            function createPointMaterial(type, color) {
                return new THREE.SpriteMaterial({
                    map: getShapeTexture(type, color),
                    transparent: true,
                    opacity: THEME.opacity.point
                });
            }

            function createTextTexture(text) {
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");

                const fontSize = 64;
                ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
                const metrics = ctx.measureText(text);

                canvas.width = metrics.width + 20;
                canvas.height = fontSize + 20;

                // canvas resize resets ctx state
                ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
                ctx.textBaseline = "middle";
                ctx.fillStyle = THEME.colors.text;
                ctx.fillText(text, 10, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                return { texture, width: canvas.width, height: canvas.height };
            }

            /**
            * 軸ラベル用：複数行を重み(サイズ)付きで描画
            * dataList: [ [text, weight], ... ] weightは先頭要素を基準に相対サイズ化
            */
            function createWeightedTextTexture(dataList) {
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");

                const baseVal = dataList.length > 0 ? dataList[0][1] : 1;
                const baseFontSize = 64;

                let maxWidth = 0;
                let totalHeight = 0;

                const lineProps = dataList.map(([text, val]) => {
                    const scale = val / baseVal;
                    const fontSize = Math.floor(baseFontSize * scale);
                    const lineHeight = fontSize * 1.2;

                    ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
                    const width = ctx.measureText(text).width;

                    maxWidth = Math.max(maxWidth, width);
                    totalHeight += lineHeight;
                    return { text, fontSize, lineHeight, width };
                });

                canvas.width = maxWidth + 20;
                canvas.height = totalHeight + 20;

                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.textBaseline = "top";

                let y = 10;
                for (const prop of lineProps) {
                    ctx.font = `bold ${prop.fontSize}px 'Noto Sans JP', sans-serif`;
                    const x = (canvas.width - prop.width) / 2;
                    ctx.fillText(prop.text, x, y);
                    y += prop.lineHeight;
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                return { texture, width: canvas.width, height: canvas.height };
            }

            /*==========================================================
              3) Three.js setup
              ==========================================================*/
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            const gridHelper = new THREE.GridHelper(100, 20, THEME.colors.grid, THEME.colors.grid);
            gridHelper.rotation.x = Math.PI / 2;

            // gridのチラつき(Z-fighting)軽減
            gridHelper.material.depthWrite = false;
            gridHelper.material.polygonOffset = true;
            gridHelper.material.polygonOffsetFactor = 10;
            gridHelper.material.polygonOffsetUnits = 10;
            scene.add(gridHelper);

            // Axes & labels
            const origin = new THREE.Vector3(0, 0, 0);
            const axesDefs = [
                { dir: new THREE.Vector3(1, 0, 0), color: THEME.colors.axisX, labelData: [["PC1", 1], ["安全保障強化・成長戦略・伝統的価値観", 0.5]] },
                { dir: new THREE.Vector3(0, 1, 0), color: THEME.colors.axisY, labelData: [["PC2", 1], ["反グローバリズム・右派ポピュリズム", 0.5]] },
                { dir: new THREE.Vector3(0, 0, 1), color: THEME.colors.axisZ, labelData: [["PC3", 1], ["行財政改革・緊縮", 0.5]] }
            ];

            for (const def of axesDefs) {
                scene.add(new THREE.ArrowHelper(def.dir, origin, 55, def.color, 2, 1));
                const labelData = createWeightedTextTexture(def.labelData);
                const labelSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: labelData.texture, transparent: true, opacity: 0.8, depthTest: false }));
                labelSprite.position.copy(def.dir.clone().multiplyScalar(58));
                labelSprite.scale.set(labelData.width * 0.03, labelData.height * 0.03, 1);
                labelSprite.renderOrder = 900;
                scene.add(labelSprite);
            }

            // Camera / Renderer / Controls
            const initialCameraPos = { x: 0, y: 0, z: 80 };
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            /*==========================================================
              4) Candidates build (sprites/labels/tooltips/answers)
              ==========================================================*/
            const POLICY_KEY_LIST = POLICY_KEYS; // alias（意図を明確化）
            const candidateObjects = [];
            const targetSprites = [];

            function buildAnswers(rawAnswerArray) {
                const answers = {};
                if (!Array.isArray(rawAnswerArray)) {
                    for (const key of POLICY_KEY_LIST) answers[key] = null;
                    return answers;
                }
                for (let i = 0; i < POLICY_KEY_LIST.length; i++) {
                    const raw = rawAnswerArray[i];
                    answers[POLICY_KEY_LIST[i]] = raw === "-" || raw === null || raw === undefined || raw === "" ? null : Number(raw);
                }
                return answers;
            }

            function buildTooltipHtml(pt) { // 27行前後のHTMLになるため、ここは「事前生成」して userData に固定する（hoverごとの生成を避ける）
                let html = "";
                for (let i = 0; i < Q_ENTRIES.length; i++) {
                    const [label, params] = Q_ENTRIES[i];
                    const [textLow, textHigh, maxScore] = params;
                    const val = pt.answer?.[i]; if (val === "-") {
                        html += `${label}: (未回答)<br>`;
                        continue;
                    }

                    const threshold = (maxScore + 1) / 2;
                    if (val > threshold) {
                        html += `${label}: ${textHigh}(${val}/${maxScore})<br>`;
                        continue;
                    }
                    if (val < threshold) {
                        html += `${label}: ${textLow}(${val}/${maxScore})<br>`;
                        continue;
                    }

                    // ど真ん中のときの「表示文」例外（qdataの並び順とindexに依存）
                    let content = "どちらともいえない";
                    if (i === 3) content = "限定的に減税すべき";
                    else if (i >= 7 && i <= 12) content = "今のままでよい";
                    else if (i === 13) content = "GDP比2%程度とすべき";
                    else if (i === 18) content = "男系ならば女性天皇を認める";
                    else if (i === 21) content = "同姓維持で通称使用機会の拡大"; html += `${label}: ${content}(${val}/${maxScore})<br>`;
                }

                return `
                <strong>${pt.name}</strong>
                <div class="tooltip-party">${pt.party}</div>
                <div class="tooltip-answers">${html}</div>
                `;
            }

            for (const pt of pointsData) {
                const sprite = new THREE.Sprite(createPointMaterial(pt.shape, pt.color));
                sprite.position.set(pt.x, pt.y, pt.z);

                // ラベル（候補者名）: 個別テクスチャ（候補者数が多いとメモリ増）
                const textData = createTextTexture(pt.name);
                const label = new THREE.Sprite(
                    new THREE.SpriteMaterial({
                        map: textData.texture,
                        transparent: true,
                        opacity: THEME.opacity.label,
                        depthTest: false
                    })
                );
                label.position.set(pt.x, pt.y + 0.9, pt.z);
                label.scale.set(textData.width * 0.012, textData.height * 0.012, 1);
                label.renderOrder = 999;

                sprite.userData = {
                    url: pt.url,
                    html: buildTooltipHtml(pt)
                };

                scene.add(sprite);
                scene.add(label);

                candidateObjects.push({
                    name: pt.name,
                    party: pt.party,
                    sprite,
                    label,
                    position: new THREE.Vector3(pt.x, pt.y, pt.z),
                    answers: buildAnswers(pt.answer)
                });

                targetSprites.push(sprite);
            }

            /*==========================================================
              5) DOM references
              ==========================================================*/
            const legendDiv = document.getElementById("legend");
            const tooltip = document.getElementById("tooltip");
            const modal = document.getElementById("about-modal");

            const searchInput = document.getElementById("search-input");
            const searchResults = document.getElementById("search-results");

            const issueSelect = document.getElementById("issue-select");
            const valueRange = document.getElementById("value-range");
            const labelLow = document.getElementById("label-low");
            const labelHigh = document.getElementById("label-high");
            const currentValText = document.getElementById("current-val-text");
            const filterControl = document.getElementById("filter-control");
            const filterReset = document.getElementById("filter-reset");
            const filterPanel = document.getElementById("filter-panel");

            /*==========================================================
              6) Filters (party AND policy)
              - activeParty: 凡例クリック
              - currentPolicyKey: セレクトで設定
              ==========================================================*/
            let activeParty = null;
            let currentPolicyKey = null;

            function tweenOpacity(material, targetOpacity) {
                // 変化がない場合はgsap発行を抑制（大量候補者でも軽くなる）
                if (Math.abs(material.opacity - targetOpacity) < 0.001)
                    return; gsap.to(material, {
                        opacity: targetOpacity,
                        duration: THEME.duration.filter,
                        ease: "power2.out"
                    });
            }

            function applyCombinedFilter() {
                const hasParty = !!activeParty;
                const hasPolicy = !!currentPolicyKey;
                const targetVal = hasPolicy ? Number(valueRange.value) : null;
                for (const obj of candidateObjects) {
                    const partyMatch = !hasParty || obj.party === activeParty;
                    let policyMatch = true;
                    if (hasPolicy) {
                        const candidateVal = obj.answers[currentPolicyKey];
                        policyMatch = candidateVal !== null && candidateVal === targetVal;
                    }
                    const isMatch = partyMatch && policyMatch; // 表示強度（元仕様踏襲：政策フィルタ時は強く落とす）
                    let spriteOpacity, labelOpacity;
                    if (!hasParty && !hasPolicy) {
                        spriteOpacity = THEME.opacity.point;
                        labelOpacity = THEME.opacity.label;
                    } else if (hasPolicy) {
                        spriteOpacity = isMatch ? 1 : THEME.opacity.filteredOutStrong;
                        labelOpacity = isMatch ? 1 : THEME.opacity.filteredOutStrong;
                    } else {
                        spriteOpacity = isMatch ? THEME.opacity.point : THEME.opacity.dimmed;
                        labelOpacity = isMatch ? THEME.opacity.label : THEME.opacity.dimmed;
                    }

                    tweenOpacity(obj.sprite.material, spriteOpacity);
                    tweenOpacity(obj.label.material, labelOpacity);
                }
            }
            /*==========================================================
              7) Legend (party filter) -
              querySelectorAllを毎回叩かないよう、要素配列を保持
              ==========================================================*/
            const legendItemEls = [];
            function setLegendSelected(targetEl) {
                for (const el of legendItemEls) el.classList.remove("selected");
                if (targetEl) targetEl.classList.add("selected");
            }

            function renderLegend() {
                const frag = document.createDocumentFragment();
                for (const item of legendData) {

                    const div = document.createElement("div");
                    div.className = "legend-item";

                    const iconUrl = getShapeDataUrl(item.style.shape, item.style.color);
                    div.innerHTML = `<img src="${iconUrl}" class="legend-icon" alt=""><span>${item.party}</span>`;

                    div.addEventListener("click", () => {
                        const isSame = activeParty === item.party;
                        activeParty = isSame ? null : item.party;

                        setLegendSelected(isSame ? null : div);
                        applyCombinedFilter();
                    });

                    legendItemEls.push(div);
                    frag.appendChild(div);
                }

                legendDiv.appendChild(frag);
            }
            renderLegend();

            /*==========================================================
              8) Tooltip + pointer interactions
              ==========================================================*/
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            let hoveredSprite = null;
            let currentData = null;
            let mouseDownPos = { x: 0, y: 0 };

            function pickSprite(clientX, clientY) {
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(targetSprites, false);
                return intersects.length ? intersects[0].object : null;
            }

            function updateTooltipPos(clientX, clientY) {
                const w = tooltip.getBoundingClientRect().width;
                const xPos = (clientX + w > window.innerWidth) ? clientX - w : clientX + 15;

                tooltip.style.left = `${xPos}px`;
                tooltip.style.top = `${clientY - 40}px`;
            }

            function showTooltip(data) {
                tooltip.innerHTML = data.html;
                tooltip.style.display = "block";
            }

            function hideTooltip() {
                tooltip.style.display = "none";
                document.body.style.cursor = "default";
            }

            function jumpToUrl(data) {
                if (data?.url) window.open(BASE_URL + data.url, "_blank", "noopener");
            }

            function resetScale() {
                if (!hoveredSprite) return;
                gsap.to(hoveredSprite.scale, { x: 1, y: 1, duration: THEME.duration.resetScale });
                hoveredSprite = null;
            }

            window.addEventListener("pointerdown", (e) => {
                if (e.target.closest(UI_SELECTORS)) return;
                mouseDownPos = { x: e.clientX, y: e.clientY };
            });

            // PC hover（touchはhoverしない）
            window.addEventListener("pointermove", (e) => {
                if (e.pointerType === "touch") return;

                if (e.target.closest(UI_SELECTORS) || e.buttons > 0) {
                    hideTooltip();
                    return;
                }

                const hit = pickSprite(e.clientX, e.clientY);
                if (!hit) {
                    hideTooltip();
                    resetScale();
                    return;
                }

                if (hoveredSprite !== hit) {
                    resetScale();
                    hoveredSprite = hit;
                    gsap.to(hit.scale, { x: 1.5, y: 1.5, duration: THEME.duration.hover, ease: "power3.out" });
                }

                currentData = hit.userData;
                showTooltip(currentData);
                updateTooltipPos(e.clientX, e.clientY);
                document.body.style.cursor = "pointer";
            });

            // PC click = open, Touch tap = show tooltip
            window.addEventListener("pointerup", (e) => {
                if (e.target.closest(UI_SELECTORS)) return;

                const dist = Math.hypot(e.clientX - mouseDownPos.x, e.clientY - mouseDownPos.y);
                if (dist > 5) return;

                const hit = pickSprite(e.clientX, e.clientY);
                if (!hit) {
                    if (e.pointerType === "touch") {
                        hideTooltip();
                        resetScale();
                    }
                    return;
                }

                const data = hit.userData;

                if (e.pointerType === "touch") {
                    // tap => show tooltip
                    if (hoveredSprite !== hit) {
                        resetScale();
                        hoveredSprite = hit;
                        gsap.to(hit.scale, { x: 1.5, y: 1.5, duration: THEME.duration.hover });
                    }
                    currentData = data;
                    showTooltip(data);
                    updateTooltipPos(e.clientX, e.clientY);
                } else {
                    // click => open detail
                    jumpToUrl(data);
                }
            });

            // Tooltip tap => open detail (mobile)
            tooltip.addEventListener("pointerup", (e) => {
                e.stopPropagation();
                if (currentData) jumpToUrl(currentData);
            });

            /*==========================================================
              9) Render loop
              ==========================================================*/
            function animate() {
                requestAnimationFrame(animate);

                const time = performance.now() * 0.005;
                const pulseScale = 1.4 + Math.sin(time) * 0.4;

                for (const obj of candidateObjects) {
                    if (obj.sprite === hoveredSprite) continue;

                    const targetScale = (activeParty && obj.party === activeParty) ? pulseScale : 1;
                    if (Math.abs(obj.sprite.scale.x - targetScale) > 0.01) {
                        obj.sprite.scale.set(targetScale, targetScale, 1);
                    }
                }

                controls.update();
                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            /*==========================================================
              10) About modal
              ==========================================================*/
            document.getElementById("about-btn").addEventListener("click", () => {
                modal.style.display = "flex";
            });
            document.getElementById("close-modal").addEventListener("click", () => {
                modal.style.display = "none";
            });
            window.addEventListener("click", (e) => {
                if (e.target === modal) modal.style.display = "none";
            });

            /*==========================================================
              11) Search
              ==========================================================*/
            searchInput.addEventListener("input", (e) => {
                const val = e.target.value.trim();
                searchResults.innerHTML = "";

                if (!val) {
                    searchResults.style.display = "none";
                    return;
                }

                const matches = candidateObjects.filter(obj => obj.name.includes(val) || obj.party.includes(val));
                if (matches.length === 0) {
                    searchResults.style.display = "none";
                    return;
                }

                const frag = document.createDocumentFragment();
                for (const match of matches) {
                    const li = document.createElement("li");
                    li.className = "search-item";
                    li.innerHTML = `<span>${match.name}</span><span class="search-party">${match.party}</span>`;

                    li.addEventListener("click", () => {
                        focusCandidate(match);
                        searchResults.style.display = "none";
                        searchInput.value = match.name;
                    });

                    frag.appendChild(li);
                }

                searchResults.appendChild(frag);
                searchResults.style.display = "block";
            });

            // Enter: first item or reset view
            searchInput.addEventListener("keydown", (e) => {
                if (e.key !== "Enter") return;

                const val = searchInput.value.trim();
                if (!val) {
                    resetView();
                    searchInput.blur();
                    return;
                }

                const first = searchResults.querySelector(".search-item");
                if (first) {
                    first.click();
                    searchInput.blur();
                }
            });

            function focusCandidate(candidateObj) {
                const targetPos = candidateObj.position;

                gsap.to(camera.position, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z + 15,
                    duration: THEME.duration.camera,
                    ease: "power3.inOut",
                    onUpdate: () => controls.update()
                });

                gsap.to(controls.target, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    duration: THEME.duration.camera,
                    ease: "power3.inOut"
                });
            }

            function resetView() {
                gsap.to(camera.position, {
                    x: initialCameraPos.x,
                    y: initialCameraPos.y,
                    z: initialCameraPos.z,
                    duration: THEME.duration.camera,
                    ease: "power3.inOut",
                    onUpdate: () => controls.update()
                });

                gsap.to(controls.target, {
                    x: 0, y: 0, z: 0,
                    duration: THEME.duration.camera,
                    ease: "power3.inOut"
                });
            }

            /*==========================================================
              12) Policy filter UI
              ==========================================================*/
            function setFilterControlEnabled(enabled) {
                filterControl.classList.toggle("is-disabled", !enabled);
            }

            function updateValueDisplay() {
                currentValText.textContent = valueRange.value;
            }

            function resetFilter() {
                issueSelect.value = "";
                currentPolicyKey = null;

                setFilterControlEnabled(false);
                labelLow.textContent = "---";
                labelHigh.textContent = "---";
                currentValText.textContent = "-";

                applyCombinedFilter();
            }

            function onIssueChange() {
                const key = issueSelect.value;
                if (!key || !qdata[key]) {
                    resetFilter();
                    return;
                }

                const [low, high, scale] = qdata[key];
                currentPolicyKey = key;

                setFilterControlEnabled(true);

                labelLow.textContent = `1: ${low}`;
                labelHigh.textContent = `${scale}: ${high}`;

                valueRange.max = String(scale);
                valueRange.value = String(Math.ceil(scale / 2));

                updateValueDisplay();
                applyCombinedFilter();
            }

            function onValueChange() {
                updateValueDisplay();
                applyCombinedFilter();
            }

            function initFilterUI() {
                // select options: まとめてappend（reflow抑制）
                const frag = document.createDocumentFragment();
                for (const key of POLICY_KEY_LIST) {
                    const opt = document.createElement("option");
                    opt.value = key;
                    opt.textContent = key;
                    frag.appendChild(opt);
                }
                issueSelect.appendChild(frag);

                issueSelect.addEventListener("change", onIssueChange);
                valueRange.addEventListener("input", onValueChange);
                filterReset.addEventListener("click", resetFilter);
            }
            initFilterUI();

            /*==========================================================
              13) Mobile: tap header to minimize/expand + dynamic stacking
              ==========================================================*/
            const mqMobile = window.matchMedia("(max-width: 600px)");
            const legendTitleEl = legendDiv.querySelector(".legend-title");
            const filterHeaderEl = filterPanel.querySelector(".filter-header");

            function updateMobileLayout() {
                if (!mqMobile.matches) {
                    filterPanel.style.bottom = "";
                    return;
                }

                // legend(下)の高さに応じて filter-panel を上へ積む
                const legendBottom = 15; // CSSのmobile bottomに合わせる
                const gap = 10;
                const legendH = legendDiv.getBoundingClientRect().height;

                filterPanel.style.bottom = `${legendBottom + legendH + gap}px`;
            }

            function setMinimized(panel, minimized) {
                panel.classList.toggle("minimized", minimized);
                updateMobileLayout();
            }

            function toggleMinimized(panel) {
                setMinimized(panel, !panel.classList.contains("minimized"));
            }

            // Legend: tap title
            legendTitleEl?.addEventListener("click", (e) => {
                if (!mqMobile.matches) return;
                e.stopPropagation();
                toggleMinimized(legendDiv);
            });

            // Filter: tap header (except reset button)
            filterHeaderEl?.addEventListener("click", (e) => {
                if (!mqMobile.matches) return;
                if (e.target.closest("#filter-reset")) return;
                toggleMinimized(filterPanel);
            });

            function applyResponsivePanels() {
                if (mqMobile.matches) {
                    setMinimized(legendDiv, true);
                    setMinimized(filterPanel, true);
                } else {
                    setMinimized(legendDiv, false);
                    setMinimized(filterPanel, false);
                    filterPanel.style.bottom = "";
                }
            }

            applyResponsivePanels();

            // Safari互換
            if (mqMobile.addEventListener) mqMobile.addEventListener("change", applyResponsivePanels);
            else mqMobile.addListener(applyResponsivePanels);

            window.addEventListener("resize", updateMobileLayout);
        }

        main();
    </script>
</body>

</html>
